"""
BSC Quest Executor - Execution Layer

Responsibilities:
1. Execute transactions generated by TypeScript
2. Get transaction execution results and receipt
3. Call validator for verification
4. Return scoring results
"""

import subprocess
import json
import base64
import tempfile
import os
from typing import Dict, Any, Optional
from web3 import Web3
from eth_account import Account


class QuestExecutor:
    """Quest Executor"""
    
    def __init__(self, w3: Web3, private_key: str):
        """
        Initialize executor
        
        Args:
            w3: Web3 instance
            private_key: Test account private key
        """
        self.w3 = w3
        self.private_key = private_key
        self.account = Account.from_key(private_key)
        self.address = self.account.address
    
    def execute_transaction(
        self,
        tx: Dict[str, Any],
        validator=None,
        token_address: str = None,
        target_address_for_token: str = None,
        token_out_address: str = None,
        spender_address: str = None,
        lp_token_address: str = None,
        pool_address: str = None,
        nft_address: str = None,
        nft_token_id: int = None,
        operator_address: str = None,
        nft_type: str = None,
        counter_contract_address: str = None,
        message_board_contract_address: str = None,
        proxy_address: str = None,
        implementation_address: str = None,
        expected_value: int = None,
        from_address: str = None,
        requires_contract: bool = False
    ) -> Dict[str, Any]:
        """
        Execute transaction and verify
        
        Args:
            tx: Transaction object
            validator: Validator instance
            token_address: ERC20 token address (optional, for querying token balance)
            target_address_for_token: Target address (for querying its token balance)
            token_out_address: Output token address (optional, for token-to-token swap)
            spender_address: Spender address (for querying allowance)
            lp_token_address: LP token address (optional, for liquidity operations)
            counter_contract_address: SimpleCounter contract address (for querying counter value)
            message_board_contract_address: MessageBoard contract address (for querying message value)
            
        Returns:
            Dictionary containing transaction result and validation result
        """
        print("="*80)
        print("‚öôÔ∏è  Starting transaction execution...")
        print("="*80)
        
        # Check if this is a query operation (returns query_result instead of transaction)
        if 'query_result' in tx:
            print("üîç Detected query operation (no transaction required)")
            return self._handle_query_operation(tx, validator)
        
        # Get target address (if any)
        target_address = tx.get('to')
        
        # Get pre-transaction state (including target address state and token balance)
        state_before = self._get_state_snapshot(
            target_address,
            token_address=token_address,
            target_address_for_token=target_address_for_token,
            token_out_address=token_out_address,
            spender_address=spender_address,
            lp_token_address=lp_token_address,
            pool_address=pool_address,
            nft_address=nft_address,
            nft_token_id=nft_token_id,
            operator_address=operator_address,
            nft_type=nft_type,
            counter_contract_address=counter_contract_address,
            message_board_contract_address=message_board_contract_address,
            proxy_address=proxy_address,
            implementation_address=implementation_address,
            from_address=from_address,
            requires_contract=requires_contract
        )
        # Add expected_value to state_before
        if expected_value is not None:
            state_before['expected_value'] = expected_value
        if proxy_address is not None:
            state_before['proxy_address'] = proxy_address.lower()
        
        try:
            # 1. Prepare transaction
            transaction = self._prepare_transaction(tx)
            
            # 2. Sign transaction
            signed_txn = self.w3.eth.account.sign_transaction(
                transaction,
                self.private_key
            )
            
            # 3. Send transaction
            raw_tx = getattr(signed_txn, 'rawTransaction', None) or getattr(signed_txn, 'raw_transaction', None)
            if raw_tx is None:
                raise AttributeError("Cannot get signed transaction data")
            
            tx_hash = self.w3.eth.send_raw_transaction(raw_tx)
            print(f"‚úÖ Transaction sent: {tx_hash.hex()}")
            
            # 4. Wait for confirmation
            print(f"‚õèÔ∏è  Waiting for transaction confirmation...")
            receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash, timeout=30)
            
            print(f"‚úÖ Transaction confirmed")
            print(f"   Block: {receipt['blockNumber']}")
            print(f"   Gas Used: {receipt['gasUsed']}")
            print(f"   Status: {'Success' if receipt['status'] == 1 else 'Failed'}")
            
            # 5. Get post-transaction state (including target address state and token balance)
            state_after = self._get_state_snapshot(
                target_address,
                token_address=token_address,
                target_address_for_token=target_address_for_token,
                token_out_address=token_out_address,
                spender_address=spender_address,
                lp_token_address=lp_token_address,
                pool_address=pool_address,
                nft_address=nft_address,
                nft_token_id=nft_token_id,
                operator_address=operator_address,
                nft_type=nft_type,
                counter_contract_address=counter_contract_address,
                message_board_contract_address=message_board_contract_address,
                proxy_address=proxy_address,
                implementation_address=implementation_address,
                from_address=from_address,
                requires_contract=requires_contract
            )
            
            # 6. Convert receipt to standard format
            receipt_dict = self._convert_receipt(receipt)
            
            # 7. Verification (if validator provided)
            validation_result = None
            if validator:
                print("\n" + "="*80)
                print("üîç Starting verification...")
                print("="*80)
                validation_result = validator.validate(
                    tx=transaction,
                    receipt=receipt_dict,
                    state_before=state_before,
                    state_after=state_after
                )
                
                # Print validation result
                self._print_validation_result(validation_result)
            
            return {
                'success': True,
                'tx_hash': tx_hash.hex(),
                'receipt': receipt_dict,
                'state_before': state_before,
                'state_after': state_after,
                'validation': validation_result
            }
            
        except Exception as e:
            print(f"\n‚ùå Transaction execution failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'state_before': state_before
            }
    
    def _prepare_transaction(self, tx: Dict[str, Any]) -> Dict[str, Any]:
        """
        Prepare transaction object
        
        Args:
            tx: Original transaction object
            
        Returns:
            Prepared transaction object
        """
        from eth_utils import to_checksum_address
        
        # Get chain ID
        chain_id = self.w3.eth.chain_id
        
        transaction = {
            'from': to_checksum_address(self.address),
            'to': to_checksum_address(tx['to']) if tx.get('to') else None,
            'value': int(tx.get('value', 0)),
            'gas': int(tx.get('gasLimit', tx.get('gas', 500000))),  # Supports gasLimit or gas
            'nonce': self.w3.eth.get_transaction_count(self.address),
            'chainId': chain_id,  # Add chainId
        }
        
        # Handle gas price
        tx_type = tx.get('type', 0)
        if tx_type == 2:
            # EIP-1559
            transaction['maxPriorityFeePerGas'] = int(tx.get('maxPriorityFeePerGas', 10**9))
            transaction['maxFeePerGas'] = int(tx.get('maxFeePerGas', 2 * 10**9))
            transaction['type'] = 2
        else:
            # Legacy
            transaction['gasPrice'] = int(tx.get('gasPrice', 10**9))
        
        # Handle data
        if 'data' in tx and tx['data']:
            transaction['data'] = tx['data']
        
        return transaction
    
    def _get_state_snapshot(
        self,
        target_address: str = None,
        token_address: str = None,
        target_address_for_token: str = None,
        token_out_address: str = None,
        spender_address: str = None,
        lp_token_address: str = None,
        pool_address: str = None,
        nft_address: str = None,
        nft_token_id: int = None,
        operator_address: str = None,
        nft_type: str = None,
        counter_contract_address: str = None,
        message_board_contract_address: str = None,
        proxy_address: str = None,
        implementation_address: str = None,
        from_address: str = None,
        requires_contract: bool = False
    ) -> Dict[str, Any]:
        """
        Get current on-chain state snapshot
        
        Args:
            target_address: Target address (optional), if provided, gets target address state
            counter_contract_address: SimpleCounter contract address (optional), if provided, gets counter value
            message_board_contract_address: MessageBoard contract address (optional), if provided, gets message value
        
        Returns:
            State snapshot dictionary
        """
        snapshot = {
            'block_number': self.w3.eth.block_number,
            'balance': self.w3.eth.get_balance(self.address),
            'nonce': self.w3.eth.get_transaction_count(self.address),
        }
        
        # If target address provided, get target address state
        if target_address:
            from eth_utils import to_checksum_address
            import time
            
            target_addr = to_checksum_address(target_address)
            
            # Get target address balance
            snapshot['target_balance'] = self.w3.eth.get_balance(target_addr)
            
            # Only check contract code if requires_contract is True
            if requires_contract:
                # Get target address code size (determine if it is a contract)
                # Retry getting code multiple times to trigger Anvil pulling from remote
                code = None
                for attempt in range(3):
                    try:
                        code = self.w3.eth.get_code(target_addr)
                        code_len = len(code) if code else 0
                        
                        if attempt == 0:
                            print(f"üîç Checking contract code for {target_addr[:10]}... (attempt {attempt + 1})")
                            print(f"   Code length: {code_len} bytes")
                        
                        if code and code_len > 2:
                            # Successfully retrieved contract code
                            print(f"   ‚úÖ Contract code found: {code_len} bytes")
                            break
                        
                        # If not retrieved first time, try additional RPC calls to trigger data fetch
                        if attempt < 2:
                            print(f"   ‚ö†Ô∏è  No code found, trying to trigger data fetch...")
                            # Try to get storage, might trigger contract data loading
                            try:
                                storage = self.w3.eth.get_storage_at(target_addr, 0)
                                print(f"   Storage at slot 0: {storage.hex()[:20]}...")
                            except Exception as se:
                                print(f"   Storage fetch error: {se}")
                            # Try getting balance again
                            bal = self.w3.eth.get_balance(target_addr)
                            print(f"   Balance: {bal} wei")
                            time.sleep(0.2)  # Slightly longer wait
                    except Exception as e:
                        print(f"   ‚ùå Error getting code (attempt {attempt + 1}): {e}")
                        if attempt < 2:
                            time.sleep(0.2)
                
                final_code_size = len(code) if code and len(code) > 2 else 0
                snapshot['contract_code_size'] = final_code_size
                
                if final_code_size == 0:
                    print(f"   ‚ö†Ô∏è  WARNING: Final contract code size is 0 for {target_addr}")
            else:
                # If not expecting a contract, set contract_code_size to 0 without checking
                snapshot['contract_code_size'] = 0
        
        # If token address provided, get token balance
        if token_address:
            from eth_utils import to_checksum_address
            
            token_addr = to_checksum_address(token_address)
            agent_addr = to_checksum_address(self.address)
            
            # If from_address provided, query from_address balance (for transferFrom)
            # Otherwise query agent balance
            balance_owner_addr = to_checksum_address(from_address) if from_address else agent_addr
            
            # Get token balance (agent or from_address)
            try:
                # ERC20 balanceOf function selector: 0x70a08231
                # balanceOf(address) -> uint256
                data = '0x70a08231' + '000000000000000000000000' + balance_owner_addr[2:]
                result = self.w3.eth.call({
                    'to': token_addr,
                    'data': data
                })
                snapshot['token_balance'] = int(result.hex(), 16)
                owner_label = "from_address" if from_address else "agent"
                print(f"üìä Token balance ({owner_label}): {snapshot['token_balance']} ({snapshot['token_balance'] / 10**18:.6f})")
            except Exception as e:
                print(f"‚ö†Ô∏è  Error getting token balance: {e}")
                snapshot['token_balance'] = 0
            
            # If target address provided, get target address token balance
            if target_address_for_token:
                target_token_addr = to_checksum_address(target_address_for_token)
                try:
                    data = '0x70a08231' + '000000000000000000000000' + target_token_addr[2:]
                    result = self.w3.eth.call({
                        'to': token_addr,
                        'data': data
                    })
                    snapshot['target_token_balance'] = int(result.hex(), 16)
                    print(f"üìä Token balance (target): {snapshot['target_token_balance']} ({snapshot['target_token_balance'] / 10**18:.6f})")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Error getting target token balance: {e}")
                    snapshot['target_token_balance'] = 0
            
            # If spender address provided, get allowance
            # For transferFrom: owner=from_address, spender=agent
            # For other operations: owner=agent, spender=spender_address
            if spender_address:
                spender_addr = to_checksum_address(spender_address)
                # For transferFrom: owner=from_address, spender=agent
                # For others: owner=agent, spender=spender_address
                allowance_owner = balance_owner_addr if from_address else agent_addr
                allowance_spender = agent_addr if from_address else spender_addr
                
                try:
                    # ERC20 allowance function selector: 0xdd62ed3e
                    # allowance(address owner, address spender) -> uint256
                    # Encode: owner (32 bytes) + spender (32 bytes)
                    data = '0xdd62ed3e' + '000000000000000000000000' + allowance_owner[2:] + '000000000000000000000000' + allowance_spender[2:]
                    result = self.w3.eth.call({
                        'to': token_addr,
                        'data': data
                    })
                    snapshot['allowance'] = int(result.hex(), 16)
                    print(f"üìä Allowance (owner‚Üíspender: {allowance_spender[:10]}...): {snapshot['allowance']} ({snapshot['allowance'] / 10**18:.6f})")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Error getting allowance: {e}")
                    snapshot['allowance'] = 0
        
        # If token_out_address provided, get agent output token balance
        # Used for token-to-token swap, query output token balance
        if token_out_address:
            from eth_utils import to_checksum_address
            
            token_out_addr = to_checksum_address(token_out_address)
            agent_addr = to_checksum_address(self.address)
            
            try:
                # ERC20 balanceOf function selector: 0x70a08231
                data = '0x70a08231' + '000000000000000000000000' + agent_addr[2:]
                result = self.w3.eth.call({
                    'to': token_out_addr,
                    'data': data
                })
                balance = int(result.hex(), 16)
                snapshot['target_token_balance'] = balance  # For swap operations
                snapshot['token_b_balance'] = balance  # For liquidity operations (token B)
                print(f"üìä Token OUT balance (agent): {balance} ({balance / 10**18:.6f})")
            except Exception as e:
                print(f"‚ö†Ô∏è  Error getting token out balance: {e}")
                snapshot['target_token_balance'] = 0
                snapshot['token_b_balance'] = 0
            
            # If spender_address also provided, get token_out allowance
            # Used for add_liquidity_tokens, both tokens need approval
            if spender_address:
                spender_addr = to_checksum_address(spender_address)
                try:
                    # ERC20 allowance function selector: 0xdd62ed3e
                    data = '0xdd62ed3e' + '000000000000000000000000' + agent_addr[2:] + '000000000000000000000000' + spender_addr[2:]
                    result = self.w3.eth.call({
                        'to': token_out_addr,
                        'data': data
                    })
                    snapshot['token_b_allowance'] = int(result.hex(), 16)
                    print(f"üìä Token B Allowance (spender: {spender_addr[:10]}...): {snapshot['token_b_allowance']} ({snapshot['token_b_allowance'] / 10**18:.6f})")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Error getting token B allowance: {e}")
                    snapshot['token_b_allowance'] = 0
        
        # If lp_token_address provided, get agent LP token balance
        # Used for liquidity operations, query LP token balance
        if lp_token_address:
            from eth_utils import to_checksum_address
            from eth_abi import encode
            
            lp_token_addr = to_checksum_address(lp_token_address)
            agent_addr = to_checksum_address(self.address)
            
            try:
                # ERC20 balanceOf function selector: 0x70a08231
                data = '0x70a08231' + '000000000000000000000000' + agent_addr[2:]
                result = self.w3.eth.call({
                    'to': lp_token_addr,
                    'data': data
                })
                snapshot['lp_token_balance'] = int(result.hex(), 16)
                print(f"üìä LP Token balance (agent): {snapshot['lp_token_balance']} ({snapshot['lp_token_balance'] / 10**18:.6f})")
            except Exception as e:
                print(f"‚ö†Ô∏è  Error getting LP token balance: {e}")
                snapshot['lp_token_balance'] = 0
            
            # If spender_address also provided, query LP token allowance
            # This is critical for remove_liquidity as LP token needs to be approved for Router
            if spender_address:
                try:
                    spender_addr = to_checksum_address(spender_address)
                    # ERC20 allowance function selector: 0xdd62ed3e
                    # allowance(address owner, address spender) -> uint256
                    allowance_data = '0xdd62ed3e' + encode(['address', 'address'], [agent_addr, spender_addr]).hex()
                    allowance_result = self.w3.eth.call({
                        'to': lp_token_addr,
                        'data': allowance_data
                    })
                    snapshot['lp_allowance'] = int(allowance_result.hex(), 16)
                    print(f"üìä LP Token Allowance (spender: {spender_addr[:10]}...): {snapshot['lp_allowance']} ({snapshot['lp_allowance'] / 10**18:.6f})")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Error getting LP token allowance: {e}")
                    snapshot['lp_allowance'] = 0
        
        # ERC721: If ERC721 type, get NFT owner and approved address
        if nft_address and nft_token_id is not None and nft_type == 'erc721':
            from eth_utils import to_checksum_address
            
            nft_addr = to_checksum_address(nft_address)
            
            try:
                # ERC721 ownerOf function selector: 0x6352211e
                # ownerOf(uint256 tokenId) -> address
                # Encode: tokenId (32 bytes)
                token_id_hex = format(nft_token_id, '064x')  # 64 hex chars = 32 bytes
                data = '0x6352211e' + token_id_hex
                result = self.w3.eth.call({
                    'to': nft_addr,
                    'data': data
                })
                # Extract address from result (last 20 bytes)
                owner_hex = result.hex()
                if len(owner_hex) >= 42:  # 0x + 40 hex chars
                    owner_address = '0x' + owner_hex[-40:]
                    snapshot['nft_owner'] = owner_address
                    print(f"üìä NFT #{nft_token_id} owner: {owner_address}")
                else:
                    snapshot['nft_owner'] = None
                    print(f"‚ö†Ô∏è  Could not parse NFT owner from result: {owner_hex}")
            except Exception as e:
                print(f"‚ö†Ô∏è  Error getting NFT owner: {e}")
                snapshot['nft_owner'] = None
            
            # Also get NFT approved address (getApproved)
            try:
                # ERC721 getApproved function selector: 0x081812fc
                # getApproved(uint256 tokenId) -> address
                # Encode: tokenId (32 bytes)
                token_id_hex = format(nft_token_id, '064x')  # 64 hex chars = 32 bytes
                data = '0x081812fc' + token_id_hex
                result = self.w3.eth.call({
                    'to': nft_addr,
                    'data': data
                })
                # Extract address from result (last 20 bytes)
                approved_hex = result.hex()
                if len(approved_hex) >= 42:  # 0x + 40 hex chars
                    approved_address = '0x' + approved_hex[-40:]
                    # Check if zero address (no approval)
                    if approved_address == '0x' + '0' * 40:
                        snapshot['nft_approved'] = None
                        print(f"üìä NFT #{nft_token_id} approved: None (zero address)")
                    else:
                        snapshot['nft_approved'] = approved_address
                        print(f"üìä NFT #{nft_token_id} approved: {approved_address}")
                else:
                    snapshot['nft_approved'] = None
                    print(f"‚ö†Ô∏è  Could not parse NFT approved address from result: {approved_hex}")
            except Exception as e:
                print(f"‚ö†Ô∏è  Error getting NFT approved address: {e}")
                snapshot['nft_approved'] = None
        
        # If NFT address and operator address provided, query isApprovedForAll state
        if nft_address and operator_address:
            from eth_utils import to_checksum_address
            from eth_abi import encode
            
            nft_addr = to_checksum_address(nft_address)
            operator_addr = to_checksum_address(operator_address)
            agent_addr = to_checksum_address(self.address)
            
            try:
                # ERC721 isApprovedForAll function selector: 0xe985e9c5
                # isApprovedForAll(address owner, address operator) -> bool
                # Encode: owner (32 bytes) + operator (32 bytes)
                params = encode(['address', 'address'], [agent_addr, operator_addr])
                data = '0xe985e9c5' + params.hex()
                
                result = self.w3.eth.call({
                    'to': nft_addr,
                    'data': data
                })
                
                # Extract boolean from result (32 bytes)
                result_hex = result.hex()
                # Boolean is in the last byte, 0x01 = true, 0x00 = false
                if len(result_hex) >= 2:
                    # Remove '0x' prefix and get last byte
                    is_approved = int(result_hex[-1]) == 1 if result_hex[-1] in ['0', '1'] else int(result_hex[-2:], 16) > 0
                    snapshot['is_approved_for_all'] = is_approved
                    print(f"üìä isApprovedForAll (operator: {operator_addr[:10]}...): {is_approved}")
                else:
                    snapshot['is_approved_for_all'] = False
                    print(f"‚ö†Ô∏è  Could not parse isApprovedForAll result: {result_hex}")
            except Exception as e:
                print(f"‚ö†Ô∏è  Error getting isApprovedForAll status: {e}")
                snapshot['is_approved_for_all'] = False
        
        # ERC1155: If ERC1155 type, query balance
        # ERC1155 uses balanceOf(address, uint256) instead of ownerOf(uint256)
        if nft_address and nft_token_id is not None and nft_type == 'erc1155':
            from eth_utils import to_checksum_address
            from eth_abi import encode
            
            nft_addr = to_checksum_address(nft_address)
            agent_addr = to_checksum_address(self.address)
            
            try:
                # ERC1155 balanceOf function selector: 0x00fdd58e
                # balanceOf(address account, uint256 id) -> uint256
                params = encode(['address', 'uint256'], [agent_addr, nft_token_id])
                data = '0x00fdd58e' + params.hex()
                
                result = self.w3.eth.call({
                    'to': nft_addr,
                    'data': data
                })
                
                # Extract balance from result (uint256)
                balance = int(result.hex(), 16)
                snapshot['erc1155_balance'] = balance
                print(f"üìä ERC1155 balance (agent, token #{nft_token_id}): {balance}")
            except Exception as e:
                # If failed, might not be ERC1155 token (could be ERC721)
                # Or query failed
                print(f"‚ö†Ô∏è  Error getting ERC1155 balance (agent): {e}")
                snapshot['erc1155_balance'] = 0
            
            # If target address provided, query target address ERC1155 balance
            if target_address_for_token:
                target_addr = to_checksum_address(target_address_for_token)
                try:
                    params = encode(['address', 'uint256'], [target_addr, nft_token_id])
                    data = '0x00fdd58e' + params.hex()
                    
                    result = self.w3.eth.call({
                        'to': nft_addr,
                        'data': data
                    })
                    
                    balance = int(result.hex(), 16)
                    snapshot['target_erc1155_balance'] = balance
                    print(f"üìä ERC1155 balance (target, token #{nft_token_id}): {balance}")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Error getting ERC1155 balance (target): {e}")
                    snapshot['target_erc1155_balance'] = 0
        
        # SimpleCounter: If counter contract address provided, get counter value
        if counter_contract_address:
            from eth_utils import to_checksum_address
            
            counter_addr = to_checksum_address(counter_contract_address)
            
            try:
                # SimpleCounter getCounter function selector: 0x8ada066e
                # getCounter() -> uint256
                data = '0x8ada066e'
                result = self.w3.eth.call({
                    'to': counter_addr,
                    'data': data
                })
                counter_value = int(result.hex(), 16)
                snapshot['counter_value'] = counter_value
                print(f"üìä Counter value: {counter_value}")
            except Exception as e:
                print(f"‚ö†Ô∏è  Error getting counter value: {e}")
                snapshot['counter_value'] = 0
        
        # MessageBoard: If message board contract address provided, get message value
        if message_board_contract_address:
            from eth_utils import to_checksum_address
            
            message_addr = to_checksum_address(message_board_contract_address)
            
            try:
                # MessageBoard getMessage function selector: 0xce6d41de
                # getMessage() -> string
                data = '0xce6d41de'
                result = self.w3.eth.call({
                    'to': message_addr,
                    'data': data
                })
                
                # Decode string from ABI encoded data
                # Skip first 32 bytes (offset), next 32 bytes is length, then the string
                if len(result) > 64:
                    # Offset is at bytes 0-32, length is at bytes 32-64
                    length = int.from_bytes(result[32:64], 'big')
                    # String data starts at byte 64
                    string_bytes = result[64:64+length]
                    message_value = string_bytes.decode('utf-8', errors='ignore')
                    snapshot['message_value'] = message_value
                    print(f"üìä Message value: \"{message_value}\"")
                else:
                    snapshot['message_value'] = ''
                    print(f"üìä Message value: (empty)")
            except Exception as e:
                print(f"‚ö†Ô∏è  Error getting message value: {e}")
                snapshot['message_value'] = ''
        
        # DelegateCall: If proxy and implementation addresses provided, get their values
        if proxy_address and implementation_address:
            from eth_utils import to_checksum_address
            
            proxy_addr = to_checksum_address(proxy_address)
            impl_addr = to_checksum_address(implementation_address)
            
            # getValue function selector: 0x20965255
            # getValue() -> uint256
            data = '0x20965255'
            
            # Query proxy value
            try:
                result = self.w3.eth.call({
                    'to': proxy_addr,
                    'data': data
                })
                proxy_value = int(result.hex(), 16)
                snapshot['proxy_value'] = proxy_value
                print(f"üìä Proxy value: {proxy_value}")
            except Exception as e:
                print(f"‚ö†Ô∏è  Error getting proxy value: {e}")
                snapshot['proxy_value'] = 0
            
            # Query implementation value
            try:
                result = self.w3.eth.call({
                    'to': impl_addr,
                    'data': data
                })
                impl_value = int(result.hex(), 16)
                snapshot['implementation_value'] = impl_value
                print(f"üìä Implementation value: {impl_value}")
            except Exception as e:
                print(f"‚ö†Ô∏è  Error getting implementation value: {e}")
                snapshot['implementation_value'] = 0
        
        # Staking: If pool_address provided, get user staked shares
        if pool_address:
            from eth_utils import to_checksum_address
            from eth_abi import encode
            
            pool_addr = to_checksum_address(pool_address)
            agent_addr = to_checksum_address(self.address)
            
            # CakePool: userInfo function selector: 0x1959a002
            # userInfo(address) returns (uint256 shares, uint256 lastDepositedTime, uint256 cakeAtLastUserAction, ...)
            data = '0x1959a002' + encode(['address'], [agent_addr]).hex()
            
            try:
                result = self.w3.eth.call({
                    'to': pool_addr,
                    'data': data
                })
                # Parse the result: first 32 bytes is shares
                if len(result) >= 32:
                    staked_amount = int(result[:32].hex(), 16)
                    snapshot['staked_amount'] = staked_amount
                    print(f"üìä Staked shares: {staked_amount / 10**18:.4f}")
                else:
                    snapshot['staked_amount'] = 0
            except Exception as e:
                print(f"‚ö†Ô∏è  Error getting staked shares: {e}")
                snapshot['staked_amount'] = 0
        
        return snapshot
    
    def _convert_receipt(self, receipt) -> Dict[str, Any]:
        """
        Convert receipt to standard dictionary format
        
        Args:
            receipt: Web3 receipt object
            
        Returns:
            Standard format receipt dictionary
        """
        receipt_dict = {
            'transactionHash': receipt['transactionHash'].hex() if isinstance(receipt['transactionHash'], bytes) else receipt['transactionHash'],
            'blockHash': receipt['blockHash'].hex() if isinstance(receipt['blockHash'], bytes) else receipt['blockHash'],
            'blockNumber': receipt['blockNumber'],
            'from': receipt['from'],
            'to': receipt['to'],
            'gasUsed': receipt['gasUsed'],
            'cumulativeGasUsed': receipt.get('cumulativeGasUsed', receipt['gasUsed']),
            'contractAddress': receipt.get('contractAddress'),
            'status': receipt['status'],
            'logsBloom': receipt.get('logsBloom', '0x' + '0' * 512),
            'type': receipt.get('type', '0x0'),
            'effectiveGasPrice': receipt.get('effectiveGasPrice', 0),
            'transactionIndex': receipt.get('transactionIndex', 0),
        }
        
        # Convert logs
        if receipt.get('logs'):
            converted_logs = []
            for log in receipt['logs']:
                converted_log = {
                    'address': log['address'],
                    'topics': [t.hex() if isinstance(t, bytes) else t for t in log['topics']],
                    'data': log['data'],
                    'blockNumber': log['blockNumber'],
                    'transactionHash': log['transactionHash'].hex() if isinstance(log['transactionHash'], bytes) else log['transactionHash'],
                    'transactionIndex': log.get('transactionIndex', 0),
                    'blockHash': log['blockHash'].hex() if isinstance(log['blockHash'], bytes) else log['blockHash'],
                    'logIndex': log.get('logIndex', 0),
                    'removed': log.get('removed', False),
                }
                converted_logs.append(converted_log)
            receipt_dict['logs'] = converted_logs
        else:
            receipt_dict['logs'] = []
        
        return receipt_dict
    
    def _print_validation_result(self, result: Dict[str, Any]):
        """
        Print validation result
        
        Args:
            result: Validation result dictionary
        """
        print(f"\nValidation Result:")
        print(f"  Passed: {'‚úÖ Yes' if result.get('passed') else '‚ùå No'}")
        print(f"  Score: {result.get('score', 0)} / {result.get('max_score', 0)}")
        
        if result.get('checks'):
            print(f"\nChecks:")
            for check in result['checks']:
                status = "‚úÖ" if check.get('passed') else "‚ùå"
                print(f"    {status} {check.get('name')}: {check.get('message', '')}")
        
        if result.get('feedback'):
            print(f"\nFeedback: {result.get('feedback')}")
    
    def _handle_query_operation(
        self,
        tx: Dict[str, Any],
        validator=None
    ) -> Dict[str, Any]:
        """
        Handle query operation (no transaction required)
        
        Args:
            tx: Query result object (contains 'query_result' field)
            validator: Validator instance
            
        Returns:
            Dictionary containing query result and validation result
        """
        print("="*80)
        print("üîç Processing query operation...")
        print("="*80)
        
        query_result = tx.get('query_result', {})
        success = query_result.get('success', False)
        
        if success:
            print("‚úÖ Query executed successfully")
            if 'data' in query_result:
                print(f"üìä Query result: {query_result['data']}")
        else:
            error = query_result.get('error', 'Unknown error')
            print(f"‚ùå Query failed: {error}")
        
        # Get state snapshot for validation (query address balance, token balance, or allowance)
        # For query operations, we need to get the actual value to compare
        state_before = {'balance': 0, 'token_balance': 0, 'allowance': 0}
        
        # Always capture current block number and gas price as reference for validation
        try:
            current_block = self.w3.eth.block_number
            state_before['reference_block_number'] = current_block
        except Exception as e:
            print(f"‚ö†Ô∏è  Warning: Could not get current block number: {e}")
        
        try:
            # Capture current gas price info for validation
            # Try to get EIP-1559 fee data
            latest_block = self.w3.eth.get_block('latest')
            base_fee = latest_block.get('baseFeePerGas', 0)
            
            # Get suggested priority fee (typically 1-2 Gwei on BSC)
            try:
                max_priority_fee = self.w3.eth.max_priority_fee
            except:
                # Fallback: use a default priority fee
                max_priority_fee = 1 * 10**9  # 1 Gwei
            
            # Calculate max fee (base fee + priority fee with buffer)
            max_fee = base_fee + max_priority_fee
            
            state_before['reference_max_fee_per_gas'] = max_fee
            state_before['reference_max_priority_fee_per_gas'] = max_priority_fee
        except Exception as e:
            print(f"‚ö†Ô∏è  Warning: Could not get gas price info: {e}")
        
        # Extract validator attributes
        if validator:
            from eth_utils import to_checksum_address
            
            # Check if this is an allowance query
            if hasattr(validator, 'owner_address') and hasattr(validator, 'spender_address'):
                # ERC20 allowance query
                token_address = to_checksum_address(validator.token_address)
                owner_address = to_checksum_address(validator.owner_address)
                spender_address = to_checksum_address(validator.spender_address)
                
                try:
                    # ERC20 allowance function selector: 0xdd62ed3e
                    # allowance(address owner, address spender)
                    data = '0xdd62ed3e' + '000000000000000000000000' + owner_address[2:] + '000000000000000000000000' + spender_address[2:]
                    result = self.w3.eth.call({
                        'to': token_address,
                        'data': data
                    })
                    allowance = int(result.hex(), 16)
                    state_before['allowance'] = allowance
                    
                    decimals = getattr(validator, 'token_decimals', 18)
                    print(f"üìä Actual allowance (for validation): {allowance} ({allowance / 10**decimals:.6f} tokens)")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Warning: Could not get actual allowance: {e}")
            
            # Check if this is an NFT approval query
            elif hasattr(validator, 'nft_address') and hasattr(validator, 'token_id'):
                # NFT approval status query
                from eth_abi import encode
                nft_address = to_checksum_address(validator.nft_address)
                token_id = validator.token_id
                
                try:
                    # ERC721 getApproved function selector: 0x081812fc
                    # getApproved(uint256 tokenId)
                    data = '0x081812fc' + encode(['uint256'], [token_id]).hex()
                    result = self.w3.eth.call({
                        'to': nft_address,
                        'data': data
                    })
                    # Extract address from result (last 20 bytes)
                    approved_address = '0x' + result.hex()[-40:]
                    approved_address = to_checksum_address(approved_address)
                    state_before['approved_address'] = approved_address
                    
                    print(f"üìä Actual approved address (for validation): {approved_address}")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Warning: Could not get actual approved address: {e}")
            
            # Check if this is a pair reserves query
            elif hasattr(validator, 'pair_address') and hasattr(validator, 'token0_address'):
                # PancakeSwap pair reserves query
                pair_address = to_checksum_address(validator.pair_address)
                
                try:
                    # PancakePair getReserves function selector: 0x0902f1ac
                    # getReserves() returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)
                    data = '0x0902f1ac'
                    result = self.w3.eth.call({
                        'to': pair_address,
                        'data': data
                    })
                    
                    # Parse result: getReserves returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)
                    # In ABI encoding, each return value is padded to 32 bytes (64 hex chars)
                    result_hex = result.hex()
                    
                    # Remove '0x' prefix if present
                    if result_hex.startswith('0x'):
                        result_hex = result_hex[2:]
                    
                    # Reserve0: first 32 bytes (64 hex chars), uint112 is right-aligned
                    reserve0_hex = result_hex[0:64]
                    reserve0 = int(reserve0_hex, 16)
                    
                    # Reserve1: next 32 bytes (64 hex chars)
                    reserve1_hex = result_hex[64:128]
                    reserve1 = int(reserve1_hex, 16)
                    
                    # blockTimestampLast: next 32 bytes (64 hex chars), uint32 is right-aligned
                    timestamp_hex = result_hex[128:192]
                    blockTimestampLast = int(timestamp_hex, 16)
                    
                    state_before['reserve0'] = reserve0
                    state_before['reserve1'] = reserve1
                    state_before['blockTimestampLast'] = blockTimestampLast
                    
                    token0_decimals = getattr(validator, 'token0_decimals', 18)
                    token1_decimals = getattr(validator, 'token1_decimals', 18)
                    
                    print(f"üìä Actual reserves (for validation):")
                    print(f"   Reserve0: {reserve0} ({reserve0 / 10**token0_decimals:.6f} {validator.token0_symbol})")
                    print(f"   Reserve1: {reserve1} ({reserve1 / 10**token1_decimals:.6f} {validator.token1_symbol})")
                    print(f"   Block Timestamp Last: {blockTimestampLast}")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Warning: Could not get actual reserves: {e}")
                    import traceback
                    traceback.print_exc()
            
            # Check if this is a swap input amount query
            elif hasattr(validator, 'router_address') and hasattr(validator, 'token_in_address') and hasattr(validator, 'amount_out'):
                # PancakeSwap swap input amount query
                from eth_abi import encode
                from decimal import Decimal
                
                router_address = to_checksum_address(validator.router_address)
                token_in_address = to_checksum_address(validator.token_in_address)
                token_out_address = to_checksum_address(validator.token_out_address)
                amount_out = validator.amount_out
                token_in_decimals = getattr(validator, 'token_in_decimals', 18)
                token_out_decimals = getattr(validator, 'token_out_decimals', 18)
                
                try:
                    # Convert amount_out to wei
                    amount_out_wei = int(Decimal(str(amount_out)) * Decimal(10**token_out_decimals))
                    
                    # Router getAmountsIn function selector: 0x1f00ca74
                    # getAmountsIn(uint amountOut, address[] path)
                    # Encode: amountOut (uint256) + path offset (uint256) + path length (uint256) + path elements
                    
                    path = [token_in_address, token_out_address]
                    
                    # Encode the function call
                    selector = bytes.fromhex('1f00ca74')
                    # amountOut
                    encoded_amount = encode(['uint256'], [amount_out_wei])
                    # path array offset (32 bytes after amountOut = 0x40)
                    encoded_offset = encode(['uint256'], [64])
                    # path array length
                    encoded_length = encode(['uint256'], [len(path)])
                    # path elements
                    encoded_path = encode(['address'] * len(path), path)
                    
                    data = '0x' + selector.hex() + encoded_amount.hex() + encoded_offset.hex() + encoded_length.hex() + encoded_path.hex()
                    
                    result = self.w3.eth.call({
                        'to': router_address,
                        'data': data
                    })
                    
                    # Parse result: dynamic array of uint256[]
                    # For dynamic arrays in ABI encoding:
                    # First 32 bytes (64 hex chars): offset to array data (usually 0x20 = 32)
                    # At offset: 32 bytes for array length
                    # Then: array elements (each 32 bytes)
                    result_hex = result.hex()
                    
                    # Remove '0x' prefix if present
                    if result_hex.startswith('0x'):
                        result_hex = result_hex[2:]
                    
                    # First 32 bytes (64 chars): offset
                    offset_hex = result_hex[0:64]
                    offset = int(offset_hex, 16) * 2  # Convert to hex char offset
                    
                    # At offset: array length (32 bytes = 64 hex chars)
                    array_length_hex = result_hex[offset:offset+64]
                    array_length = int(array_length_hex, 16)
                    
                    # Parse array elements
                    amounts = []
                    elements_start = offset + 64
                    for i in range(array_length):
                        start = elements_start + (i * 64)
                        end = start + 64
                        amount_hex = result_hex[start:end]
                        if amount_hex:  # Check not empty
                            amounts.append(int(amount_hex, 16))
                    
                    state_before['expected_amounts'] = amounts
                    
                    print(f"üìä Actual amounts (for validation):")
                    print(f"   Required Input: {amounts[0]} ({amounts[0] / 10**token_in_decimals:.6f} {validator.token_in_symbol})")
                    if len(amounts) > 1:
                        print(f"   Desired Output: {amounts[1]} ({amounts[1] / 10**token_out_decimals:.6f} {validator.token_out_symbol})")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Warning: Could not get actual swap input amounts: {e}")
                    import traceback
                    traceback.print_exc()
            
            # Check if this is a swap output amount query
            elif hasattr(validator, 'router_address') and hasattr(validator, 'token_in_address') and hasattr(validator, 'amount_in'):
                # PancakeSwap swap output amount query
                from eth_abi import encode
                from decimal import Decimal
                
                router_address = to_checksum_address(validator.router_address)
                token_in_address = to_checksum_address(validator.token_in_address)
                token_out_address = to_checksum_address(validator.token_out_address)
                amount_in = validator.amount_in
                token_in_decimals = getattr(validator, 'token_in_decimals', 18)
                token_out_decimals = getattr(validator, 'token_out_decimals', 18)
                
                try:
                    # Convert amount_in to wei
                    amount_in_wei = int(Decimal(str(amount_in)) * Decimal(10**token_in_decimals))
                    
                    # Router getAmountsOut function selector: 0xd06ca61f
                    # getAmountsOut(uint amountIn, address[] path)
                    # Encode: amountIn (uint256) + path offset (uint256) + path length (uint256) + path elements
                    
                    path = [token_in_address, token_out_address]
                    
                    # Encode the function call
                    selector = bytes.fromhex('d06ca61f')
                    # amountIn
                    encoded_amount = encode(['uint256'], [amount_in_wei])
                    # path array offset (32 bytes after amountIn = 0x40)
                    encoded_offset = encode(['uint256'], [64])
                    # path array length
                    encoded_length = encode(['uint256'], [len(path)])
                    # path elements
                    encoded_path = encode(['address'] * len(path), path)
                    
                    data = '0x' + selector.hex() + encoded_amount.hex() + encoded_offset.hex() + encoded_length.hex() + encoded_path.hex()
                    
                    result = self.w3.eth.call({
                        'to': router_address,
                        'data': data
                    })
                    
                    # Parse result: dynamic array of uint256[]
                    # For dynamic arrays in ABI encoding:
                    # First 32 bytes (64 hex chars): offset to array data (usually 0x20 = 32)
                    # At offset: 32 bytes for array length
                    # Then: array elements (each 32 bytes)
                    result_hex = result.hex()
                    
                    # Remove '0x' prefix if present
                    if result_hex.startswith('0x'):
                        result_hex = result_hex[2:]
                    
                    # First 32 bytes (64 chars): offset
                    offset_hex = result_hex[0:64]
                    offset = int(offset_hex, 16) * 2  # Convert to hex char offset
                    
                    # At offset: array length (32 bytes = 64 hex chars)
                    array_length_hex = result_hex[offset:offset+64]
                    array_length = int(array_length_hex, 16)
                    
                    # Parse array elements
                    amounts = []
                    elements_start = offset + 64
                    for i in range(array_length):
                        start = elements_start + (i * 64)
                        end = start + 64
                        amount_hex = result_hex[start:end]
                        if amount_hex:  # Check not empty
                            amounts.append(int(amount_hex, 16))
                    
                    state_before['expected_amounts'] = amounts
                    
                    print(f"üìä Actual amounts (for validation):")
                    print(f"   Amount In: {amounts[0]} ({amounts[0] / 10**token_in_decimals:.6f} {validator.token_in_symbol})")
                    if len(amounts) > 1:
                        print(f"   Amount Out: {amounts[1]} ({amounts[1] / 10**token_out_decimals:.6f} {validator.token_out_symbol})")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Warning: Could not get actual swap output amounts: {e}")
                    import traceback
                    traceback.print_exc()
            
            # Check if this is an NFT token URI query
            elif hasattr(validator, 'nft_address') and hasattr(validator, 'token_id') and not hasattr(validator, 'expected_owner'):
                # ERC721 NFT tokenURI query
                from eth_abi import encode, decode
                
                nft_address = to_checksum_address(validator.nft_address)
                token_id = validator.token_id
                
                try:
                    # ERC721 tokenURI function selector: 0xc87b56dd
                    # tokenURI(uint256 tokenId) returns (string)
                    data = '0xc87b56dd' + encode(['uint256'], [token_id]).hex()
                    result = self.w3.eth.call({
                        'to': nft_address,
                        'data': data
                    })
                    
                    # Parse result: string (dynamic type)
                    token_uri = decode(['string'], result)[0]
                    
                    state_before['token_uri'] = token_uri
                    
                    print(f"üìä Actual NFT token URI (for validation):")
                    print(f"   NFT Address: {nft_address}")
                    print(f"   Token ID: {token_id}")
                    print(f"   Token URI: {token_uri}")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Warning: Could not get actual NFT token URI: {e}")
                    import traceback
                    traceback.print_exc()
            
            # Check if this is an NFT owner query
            elif hasattr(validator, 'nft_address') and hasattr(validator, 'token_id') and hasattr(validator, 'expected_owner'):
                # ERC721 NFT ownerOf query
                from eth_abi import encode, decode
                
                nft_address = to_checksum_address(validator.nft_address)
                token_id = validator.token_id
                
                try:
                    # ERC721 ownerOf function selector: 0x6352211e
                    # ownerOf(uint256 tokenId) returns (address)
                    data = '0x6352211e' + encode(['uint256'], [token_id]).hex()
                    result = self.w3.eth.call({
                        'to': nft_address,
                        'data': data
                    })
                    
                    # Parse result: address (32 bytes, right-padded)
                    nft_owner = decode(['address'], result)[0]
                    
                    state_before['nft_owner'] = nft_owner.lower()
                    
                    print(f"üìä Actual NFT owner (for validation):")
                    print(f"   NFT Address: {nft_address}")
                    print(f"   Token ID: {token_id}")
                    print(f"   Owner: {nft_owner}")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Warning: Could not get actual NFT owner: {e}")
                    import traceback
                    traceback.print_exc()
            
            # Check if this is a token balance query (must come before total supply check)
            elif hasattr(validator, 'query_address') and hasattr(validator, 'token_address'):
                # ERC20 balance query
                query_address = to_checksum_address(validator.query_address)
                token_address = to_checksum_address(validator.token_address)
                try:
                    # ERC20 balanceOf function selector: 0x70a08231
                    data = '0x70a08231' + '000000000000000000000000' + query_address[2:]
                    result = self.w3.eth.call({
                        'to': token_address,
                        'data': data
                    })
                    token_balance = int(result.hex(), 16)
                    state_before['token_balance'] = token_balance
                    
                    decimals = getattr(validator, 'token_decimals', 18)
                    print(f"üìä Actual token balance (for validation): {token_balance} ({token_balance / 10**decimals:.6f} tokens)")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Warning: Could not get actual token balance: {e}")
            
            # Check if this is a token total supply query
            elif hasattr(validator, 'token_address') and hasattr(validator, 'token_decimals') and not hasattr(validator, 'expected_name'):
                # ERC20 token totalSupply query (single function)
                from eth_abi import decode
                
                token_address = to_checksum_address(validator.token_address)
                
                try:
                    # Query totalSupply() - 0x18160ddd
                    total_supply_data = '0x18160ddd'
                    total_supply_result = self.w3.eth.call({
                        'to': token_address,
                        'data': total_supply_data
                    })
                    # Decode uint256
                    token_total_supply = decode(['uint256'], total_supply_result)[0]
                    
                    state_before['token_total_supply'] = token_total_supply
                    
                    token_decimals = getattr(validator, 'token_decimals', 18)
                    token_symbol = getattr(validator, 'token_symbol', 'TOKEN')
                    
                    print(f"üìä Actual token total supply (for validation):")
                    print(f"   Total Supply: {token_total_supply} wei ({token_total_supply / 10**token_decimals:.6f} {token_symbol})")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Warning: Could not get actual token total supply: {e}")
                    import traceback
                    traceback.print_exc()
            
            # Check if this is a token metadata query
            elif hasattr(validator, 'token_address') and hasattr(validator, 'expected_name') and hasattr(validator, 'expected_symbol'):
                # ERC20 token metadata query
                from eth_abi import decode
                
                token_address = to_checksum_address(validator.token_address)
                
                try:
                    # Query name() - 0x06fdde03
                    name_data = '0x06fdde03'
                    name_result = self.w3.eth.call({
                        'to': token_address,
                        'data': name_data
                    })
                    # Decode string (dynamic type)
                    token_name = decode(['string'], name_result)[0]
                    
                    # Query symbol() - 0x95d89b41
                    symbol_data = '0x95d89b41'
                    symbol_result = self.w3.eth.call({
                        'to': token_address,
                        'data': symbol_data
                    })
                    # Decode string
                    token_symbol = decode(['string'], symbol_result)[0]
                    
                    # Query decimals() - 0x313ce567
                    decimals_data = '0x313ce567'
                    decimals_result = self.w3.eth.call({
                        'to': token_address,
                        'data': decimals_data
                    })
                    # Decode uint8
                    token_decimals = decode(['uint8'], decimals_result)[0]
                    
                    # Query totalSupply() - 0x18160ddd
                    total_supply_data = '0x18160ddd'
                    total_supply_result = self.w3.eth.call({
                        'to': token_address,
                        'data': total_supply_data
                    })
                    # Decode uint256
                    token_total_supply = decode(['uint256'], total_supply_result)[0]
                    
                    state_before['token_name'] = token_name
                    state_before['token_symbol'] = token_symbol
                    state_before['token_decimals'] = token_decimals
                    state_before['token_total_supply'] = token_total_supply
                    
                    print(f"üìä Actual token metadata (for validation):")
                    print(f"   Name: {token_name}")
                    print(f"   Symbol: {token_symbol}")
                    print(f"   Decimals: {token_decimals}")
                    print(f"   Total Supply: {token_total_supply} ({token_total_supply / 10**token_decimals:.6f} {token_symbol})")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Warning: Could not get actual token metadata: {e}")
                    import traceback
                    traceback.print_exc()
            
            # Check if this is a pending rewards query
            elif hasattr(validator, 'pool_address') and hasattr(validator, 'query_address') and hasattr(validator, 'expected_pending_rewards'):
                # SimpleRewardPool pendingReward query
                from eth_abi import encode
                
                pool_address = to_checksum_address(validator.pool_address)
                query_address = to_checksum_address(validator.query_address)
                
                try:
                    # SimpleRewardPool pendingReward function selector: 0xf40f0f52
                    # pendingReward(address _user) returns (uint256)
                    data = '0xf40f0f52' + encode(['address'], [query_address]).hex()
                    result = self.w3.eth.call({
                        'to': pool_address,
                        'data': data
                    })
                    
                    # Parse result: uint256 (32 bytes)
                    result_hex = result.hex()
                    
                    # Remove '0x' prefix if present
                    if result_hex.startswith('0x'):
                        result_hex = result_hex[2:]
                    
                    # pending rewards: 32 bytes (64 hex chars)
                    pending_rewards_hex = result_hex[0:64]
                    pending_rewards = int(pending_rewards_hex, 16)
                    
                    state_before['pending_rewards'] = pending_rewards
                    
                    reward_token_decimals = getattr(validator, 'reward_token_decimals', 18)
                    print(f"üìä Actual pending rewards (for validation):")
                    print(f"   Pending rewards: {pending_rewards} wei ({pending_rewards / 10**reward_token_decimals:.6f} tokens)")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Warning: Could not get actual pending rewards: {e}")
                    import traceback
                    traceback.print_exc()
            
            # Check if this is a staked amount query
            elif hasattr(validator, 'pool_address') and hasattr(validator, 'query_address') and hasattr(validator, 'expected_staked_amount'):
                # Staking contract userInfo query
                from eth_abi import encode
                
                pool_address = to_checksum_address(validator.pool_address)
                query_address = to_checksum_address(validator.query_address)
                
                try:
                    # SimpleStaking userInfo function selector: 0x1959a002
                    # userInfo(address _user) returns (uint256 amount, uint256 depositTime)
                    data = '0x1959a002' + encode(['address'], [query_address]).hex()
                    result = self.w3.eth.call({
                        'to': pool_address,
                        'data': data
                    })
                    
                    # Parse result: amount (uint256, 32 bytes) + depositTime (uint256, 32 bytes)
                    result_hex = result.hex()
                    
                    # Remove '0x' prefix if present
                    if result_hex.startswith('0x'):
                        result_hex = result_hex[2:]
                    
                    # amount: first 32 bytes (64 hex chars)
                    amount_hex = result_hex[0:64]
                    staked_amount = int(amount_hex, 16)
                    
                    # depositTime: next 32 bytes (64 hex chars)
                    deposit_time_hex = result_hex[64:128]
                    deposit_time = int(deposit_time_hex, 16)
                    
                    state_before['staked_amount'] = staked_amount
                    state_before['deposit_time'] = deposit_time
                    
                    token_decimals = getattr(validator, 'token_decimals', 18)
                    print(f"üìä Actual staked amount (for validation):")
                    print(f"   Staked amount: {staked_amount} wei ({staked_amount / 10**token_decimals:.6f} tokens)")
                    print(f"   Deposit time: {deposit_time}")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Warning: Could not get actual staked amount: {e}")
                    import traceback
                    traceback.print_exc()
            
            # Check if this is a transaction count (nonce) query
            elif hasattr(validator, 'query_address') and not hasattr(validator, 'token_address') and not hasattr(validator, 'nft_address'):
                # Could be BNB balance query or nonce query - check validator type
                query_address = to_checksum_address(validator.query_address)
                
                # Try to get nonce if this is a nonce query
                try:
                    nonce = self.w3.eth.get_transaction_count(query_address, 'pending')
                    state_before['reference_nonce'] = nonce
                    print(f"üìä Actual nonce (for validation): {nonce}")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Warning: Could not get nonce: {e}")
                
                # Also try to get balance (for BNB balance queries)
                try:
                    balance = self.w3.eth.get_balance(query_address)
                    state_before['balance'] = balance
                    print(f"üìä Actual balance (for validation): {balance} wei ({balance / 10**18:.6f} BNB)")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Warning: Could not get actual balance: {e}")
        
        # Validate query result
        validation_result = None
        if validator:
            print("\n" + "="*80)
            print("üîç Starting validation...")
            print("="*80)
            
            # For query operations, we pass the tx object (containing query_result)
            # and state_before (containing actual balance)
            validation_result = validator.validate(
                tx=tx,
                receipt={},  # No receipt for query operations
                state_before=state_before,
                state_after={}  # No state change for query operations
            )
            
            # Print validation result
            self._print_validation_result(validation_result)
        
        return {
            'success': success,
            'query_result': query_result,
            'validation': validation_result
        }

